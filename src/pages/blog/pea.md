---
layout: '../../layouts/Blog.astro'
title: 'Partial Escape Analysis and Scalar Replacement for Java'
description: 'Paper analysis'
pubDate: 'Dec 23 2022'
heroImage: ''
tags:
  - compilers
  - programming languages
  - optimization
  - virtual machines
---

## Abstract

- **Escape analysis** allows a compiler to determine whether an **object** is **accessible outside** the **allocating method** or **thread**
- This is information is used to perform **optimizations** such as:
  - **Scalar replacement**
  - **Stack allocation**
  - **Lock elision**
- allowing to remove **abstractions** introduced by **modern programming models**

---

- most **EA** algorithms prevents there optimizations if there is 1 **branch** where the object **escapes** (no matter how unlikely this branch is at runtime)

---

- the paper presents a new **algorithm** that performs **control-flow sensitive Partial Escape Analysis (PEA)** in a **dynamic Java compiler**
- it allows **EA**, **Scalar replacement** and **Lock elision** to be performed on **individual branches**
- the algorithm is implemented on top of the **Graal open-source Java just-in-time compiler**

---

- the effect of **PEA** is evaluated on the **DaCapo**, **ScalaDaCapo** and **SpecJBB2005** benchmarks in terms of:
  - run-time
  - number and size of allocations
  - number of monitor operations

---

- it performs particularly well in case of additional levels of abstraction (code generated by the Scala compiler)
- it **reduces** the **amount of allocated memory** by up to 58.5% and **improves performance** by up to 33%

---

## Introduction

- State-of-the-art VMs employ techniques such as **advanced garbage collection**, **alias analysis** and **biased locking** to make working with **dynamically allocated objects** as efficient as possible (some **overhead** is always present)
  - **alias analysis** can't remove some **object accesses**
  - acquiring a **biased lock** is simple but not as not acquiring a lock at all
- **EA** is used to determine whether an **object** needs to be **allocated** at all and whether its **lock** can be **contended**
- **Scalar replacement**: replace **object's fields** with **local variables**
- **EA** checks if an object **escapes** its **allocating method** (whether is it accessible outside and so **needs to exist on the heap** to be accessible from some other context)
- in many cases an object escapes in a single unlikely branch (preventing optimizations)

---

- **Partial Escape Analysis (PEA)**:
  - perform optimizations in branches where the object **does not escape** and **make sure** that the object **exists in the heap in branches** where it does **escape**
- **Novel aspects**:
  - **control-flow sensitive PEA** algorithm that checks the escapability of objects for **individual branches**
  - integration of the **PEA** algorithm in **Graal Java compiler** based on **SSA form**, **speculative execution** and **deoptimization**
  - evaluation of the algorithm on a set of **benchmarks** (as before)

---

## System overview

![figure1](/blog/pea/figures/figure-1.png)

- implementation of the analysis for **Graal**, a Java just-in-time compiler (OpenJDK project) written in Java that runs on top of the **Hotspot VM**
- it can completely replace the client and server compilers but reuses all other VM components (interpreter, garbage collection subysytem, class loading, etc...)

---

- **Graal** translates **Java bytecode** into a **high-level intermediate representation** called **Graal IR** on which it performs all optimizations
- the **SSA-based IR** models both **control flow** and **data flow** dependencies between nodes
- it explicitly expresses the control flow of the code but many operations are **not fixed at specific locations** (their position is determined solely by their **data flow dependencies** and positioned by the **Scheduler**)

---

- **Graal** is very **aggressive and optimistic** and ofter makes **assumptions** about the **state** and the **behavior** of the **running program** (inheritance, branching, etc...)
- **Deoptimization**:
  - if an assumption is **invalidated**, the execution **needs to be transferred from the compiled code back to the interpreter** (which does not make assumption and can execute all code)
  - requires a **translation** from the **machine state** (native stack frames) back to the **Java VM state** (used by the interpreter)
  - **Graal IR** contains a **mapping** to **Java VM state** for all positions that can cause a **deoptimization** to occur (expressed as **FrameState nodes**)
- **FrameState nodes**:
  - consists of the **current position** (_Bytecode index and method_), the **local variables**, the **contentss of the expression stack** and the **locked objects**
  - after **inlining**, 1 position can map to **multiple Java VM stack frames**, so we have to create **chains of Frame state nodes** that describe the state of all inlined methods at the current position (by using **references** between **frame state nodes**)
  - **Graal IR** keeps the **frame states** not at the points where the actual **deoptimizations** take place, but at the points where the **side effects** may occur (**operations that cannot be reexecuted**, the other operation are reexecutable by the interpreter in case of a deoptimization)

---

## Escape Analysis (EA)

- **EA** checks whether an **allocated object escapes** (can be used from outside) the **allocating method or thread**
- Compilers use **EA** to determine the **dynamic scope** and the **lifetime** of **allocated objects**
- The result of this analysis allows the compiler to perform numerous optimizations on operations such as **object allocation**, **synchronization primitives** and **field accesses**

_Listing 1 (simple example)_

```java
class Key {
    int idx;
    Object ref;
    Key(int idx, Object ref) {
        this.idx = idx;
        this.ref = ref;
    }
    synchronized boolean equals(Key other) {
        return idx == other.idx &&
               ref == other.ref;
    }
}

static CacheKey cacheKey;
static Object cacheValue;

Object getValue(int idx, Object ref) {
    Key key = new Key(idx, ref);
    if (key.equals(cacheKey)) {
        return cacheValue;
    } else {
        return createValue(...);
    }
}
```

- the `getValue` method creates a `new Key` object and checks whether it is in the cache
- if `true` returns the cached value, otherwise creates and returns a new value through `createValue`

_Listing 2 (Listing 1 after **inlining**)_

```java
Object getValue(int idx, Object ref) {
    Key key = alloc Key;
    key.idx = idx;
    key.ref = ref;
    Key tmp1 = cacheKey;
    boolean tmp2;
    synchronized (key) {
        tmp2 = key.idx == tmp1.idx &&
               key.ref == tmp1.ref;
    }
    if (tmp2) {
        return cacheValue;
    } else {
        return createValue(...);
    }
}
```

- the `Key` constructor and the `equals` method have been **inlined** into the `getValue` method
- a `synchronized` block is created to achieve synchronization on the **inlined** `equals` method
- **no reference** to the allocated `Key` object **escapes** from the **current compilation scope**
- **no reference** to the object **exist** after the method **has returned**
- **no other thread** can ever see a **reference** to this object
- Available optimizations:
  - the **allocation** on the **garbage collected heap** can be replaced with a one on the **stack** or in other **non-garbage-collected areas** such as **Zones** (heap areas with a known limited lifetime, can be freed in bulk when a certain scope is left)
  - **Scalar replacement** can be used to remove the allocation altogether by replacing the fields of the object with local variables
  - Since the object's **lock** will **never** be **contended**, **Lock elision** can remove the synchronization on `key`

_Listing 3 (Listing 2 after **Scalar replacement** and **Lock elision**)_

```java
Object getValue(int idx, Object ref) {
    int idx1 = idx;
    Object ref1 = ref;
    Key tmp = cacheKey;
    if (idx1 == tmp.idx &&
        ref1 == tmp.ref) {
        return cacheValue;
    } else {
        return createValue(...);
    }
}
```

- the allocation is replaced with the local variables `idx1` and `ref1`
- the `synchronized` statement was removed entirely

---

- **EA** can be implemented using algorithms such as _Equi-Escape Sets_
- these algorithms build **sets of objects** with the **same escape state** (each of which is **initially in a separate set**)
- by analyzing all operations, the system can:
  - **merge sets** (e.g. an object in one set is assigned to a field of an object in another set)
  - **mark an set as escaping** (e.g. when an object in this set is assigned to a global variable)

---

## Partial Escape Analysis (PEA)

_Listing 4 (complex example)_

```java
Object getValue(int idx, Object ref) {
    Key key = new Key(idx, ref);
    if (key.equals(cacheKey)) {
        return cacheValue;
    } else {
        cacheKey = key;
        cacheValue = createValue(...);
        return cacheValue;
    }
}
```

- the object allocated in _Listing 4_ **escapes** in `cacheKey`, **EA** would consider to be **escaping** (preventing optimizations)
- if we consider only the path through the `true` branch of the `if` statement the object **does not escape**

---

- **PEA** **iterates** over the code and **maintains** the current **escape state and contents of allocated objects**:
  - initially, each allocated object is in the state **virtual** (there is no reason yet to actuallly allocate it)
  - the algorithm progresses along the control-flow and updates this state when instructions operate on the allocated objects

_Listing 5 (Listing 4 after **inlining**)_

```java
Object getValue(int idx, Object ref) {
    Key key = alloc Key;
    key.idx = idx;
    key.ref = ref;
    Key tmp1 = cacheKey;
    boolean tmp2;
    synchronized (key) {
        tmp2 = key.idx == tmp1.idx &&
               key.ref == tmp1.ref;
    }
    if (tmp2) {
        return cacheValue;
    } else {
        cacheKey = key;
        cacheValue = createValue(...);
        return cacheValue;
    }
}
```

_Listing 6 (Listing 5 after **Partial Escape Analysis**)_

```java
Object getValue(int idx, Object ref) {
    Key tmp = cacheKey;
    if (idx == tmp.idx &&
        ref == tmp.ref) {
        return cacheValue;
    } else {
        Key key = alloc Key;
        key.idx = idx;
        key.ref = ref;
        cacheKey = key;
        cacheValue = createValue(...);
        return cacheValue;
    }
}
```

- the allocation in _line 2_ is **removed**
  - an entry for this object is created
  - the object is **marked as virtual**
  - all fields have their **default value**
- the assignments to the fields `idx` and `ref` in _lines 3-4_ are **removed**
  - object's field states are updated
- when entering the **synchronized** region in _line 7_, the object is still **virtual**
  - the **monitor enter operation** is **removed**
  - the object's **state** is **augmented** with a `locked` flag (the object would have been locked if it actually existed at this point)
- the accesses to the `idx` and `ref` fields of the **virtual** objects in _lines 8-9_ are **replaced** using **object's current field states**
- when exiting the **synchronized** regioni in _line 10_, the object is still **virtual**
  - the **monitor exit operation** is **removed**
  - the `locked` flag is **removed** from the **object's state**
- at the `if` statement in _line 11_, a **copy** of the current state is created (because it has to be propagated to both successors of this **control split**)
- in _line 12_ the object is still **virtual** and the `return` ends processing this branch
- in _line 14_ the object is still **virtual** and the assignment to the `static` field `cacheKey` lets the object **escape**
  - **Materialization**: the object needs to exist, so it is created and initialized with current state of its fields at this point
  - the object is **transitioned** to the state **escaped** at this point
  - the state of its fields **cannot be used from here on** since there could be assignments to the fields from **outside the compilation scope**
- _lines 15-16_ do not affect the state of the object anymore

---

- the **effect of the allocation** is moved into one **branch** of the `if` statement
- this **do not lead to fewer allocation sites** but **reduces the dynamic number of allocations at runtime** (depends on the likelihood of the branch containing the allocation being reached, there will always be at most as many dynamic allocation as in the original code)

---

## GRAAL Partial Escape Analysis

- **PEA** is particularly **effective** if it can **interact** with other parts of the **compiler** such as **inlining**, **global value numbering** and **constant folding**

_Graal IR for the example of Listing 5 (after inlining)_

![figure2](/blog/pea/figures/figure-2.png)

- **SSA form**:
  - no more variables
  - the local variables `tmp2` is expressed using a `phi` function
  - control-flow dependencies are expressed by bold arrows pointing downwards
  - data-flow dependencies are expressed by this arrows pointing upwards

---

- **Graal's PEA**:
  1. starts iterating the **IR graph** at the `Start` node
  2. processes each node as soon as all its control flow precedessors have been processed
     - follow the _control flow_
     - branch at _control splits_
     - process `Merge` nodes as soon as all predecessors have been visited
  3. iteration stops at _control sinks_ such as `Return` and `Throw` nodes

---

- during the iteration, the system maintains a **state** that **keeps track of previously encountered object allocations**
- for each visited node, the system takes the **predecessor state** and **updates it** by **any effects** of the current **node**
- **Merge nodes** and **loop entries** are special in that there are **multiple predecessor states** (from merged branches and loop back edges) which need to be merged into 1 consistent state before processing the node
- if there is no reason to **materialize** an allocated object, it is considered to be **virtual** (the states of al lfields and the number of held locks is known and correct)
- if a **virtual** object needs to be **created in the heap**, an actual allocation needs to be **inserted** which is considered to be the **materialized value**

---

## Allocation state

_Listing 7 (simplified version of the allocation state maintained during the control flow iteration, propagated through the IR)_

```java
class Id extends Node {
    Class<?> type;
}

class ObjectState {
}

class VirtualState extends ObjectState {
    int lockCount;
    Node[] fields;
}

class EscapedState extends ObjectState {
    Node materializedValue;
}

class State {
    Map<Id, ObjectState> states;
    Map<Node, Id> aliases;
}
```

- each object allocation encountered is represented by an `Id` object
- for each `Id` object there is an `ObjectState` that describes the current knowledge aobout this allocation, **stored** in the `states` **map**
- if the allocation is still **virtual**, the state is a `VirtualState` that represents the field values and lock count
- if the allocation is **escaped**, the state is a `EscapedState` that represents the materialiezed value
- the `aliases` **map** contains a mapping from **Graal IR** nodes to `Id`s (it will initially map from the `New` node of the original program to the allocation's `Id`)

---

![figure3](/blog/pea/figures/figure-3.png)

- multiple nodes can be associated with 1 object `Id`
- 1 `Id` is always associated with exactly 1 `ObjectState`
- the rounded rectangle representing an object `Id` contains the object's type and a unique identifier
  - the `VirtualState` contains the `lockCount` and the values of the object's fields
  - the `EscapedState` contains the `materializedValue` (a reference to the node that will create the actual object at runtime)

---

## Effects on nodes on the allocation state

- 3 categories of nodes have an effect on the allocation state:
  - allocation create new **virtual objects**, therefore they always modify the state by adding new elements
  - if any of the inputs of a node is a key in the `aliased` **map**, then the node needs to be examined
  - `Merge` nodes and `LoopBegin` nodes (which represent loop headers) merge multiple states

![figure4](/blog/pea/figures/figure-4.png)

- **(a) Allocation**:
  - new `Id` and `VirtualState` objects are created
  - the `VirtualState` object is intialized with default values
  - new entries in the `aliased` and `states` **maps** are created that point
    - from the allocation to the `Id`
    - from the `Id` to the `VirtualState`
- **(b) Storing a value which is not in the `aliased` map into a field of a virtual object**
  - set the field value in the corresponding `VirtualState` object
- **(b) Loading a (non `Id`) value from a field of a virtual object**
  - replace the `Load` with the value from the corresponding field of the `VirtualState` at all its usages
- **(c) Entering a synchronization region (`MonitorEnter` node) with the locked object being a virtual object**
  - increment the `lockCount`
- **(d) Exiting a synchronization region (`MonitorExit` node) with the locked object being a virtual object**
  - decrement the `lockCount`
- **(e) Storing a virtual object into a field of another virtual object**
  - put a reference to the `Id` of the stored object into the `fields` array of the target **virtual** object
- **(f) Loading a virtual object from a field of another virtual object**
  - insert a new entry into the `aliased` **map** so that the `Load` node can be recognized as referring to the **virtual** `Integer` during further processing

---

- all these **operations** are **removed from the IR** **after** the have been **processed**
- many operations can also be replaced by contant expressions based on precise info from the state
- **equality checks on object references are always `false` when exacly 1 input is virtual**
  - the check will produce `true` if they refer to the **same** `Id`, `false` otherwise
- **type checks on virtual objects** can also be performed at **compile time** since the **exact type is known**

---

![figure5](/blog/pea/figures/figure-5.png)

- in general, inputs that refer to **escaped** objects are handled as if there are **normal values** but they are **replaced** with the `materializedValue` during processing
- **any operation that is not explicitly handled is assumed to require an actual object reference**

---

## Merge nodes

- whenever multiple branches meet at a `Merge` node, there also multiple states that need to be merged into 1 consistent state

![figure6](/blog/pea/figures/figure-6.png)

- the `MergeProcessor`, first:
  - **(a)** first creates the **intersection** of the `aliases` **maps** of all **merged states**
    - only `Id`s that **exist in all predecessor states** and **have at least 1 common `alias` will survive the merge**
- the `MergeProcessor` after, for each `Id`, it looks at the `Id`'s `ObjectState` in all precedessor states:
  - **(b)** if the `Id` **escaped in all precedessors states** a new `EscapedState` for this `Id` is added to the merged state, with the `materializedValue` poiting to a newly created `Phi` function that merges the `materializedValue`s of the precedessors
  - if some predecessors `Id`s are in the **virtual** and some in the **escaped** state, then all **virtual states** need to be **materialized** at the corresponding precessor in the control flow
  - if all predecessors `Id`s are in the **virtual** state, then a new state of the `Id` will also be **virtual** and all field values need to be **merged**
    - the `MergeProcessor` looks at the value of this fields in all precedessor `VirtualObject`s
      - if they are **identical**, this value will be the value of the field in the new `VirtualState` (this applies to `Id`s that represent allocations as well)
      - if some values differ, creates a new `Phi` node for this field (all field values need to be available at runtime, none of them can reference a **virtual** object)  
        The `MergeProcessor` check each value whether it is an `Id` and, if so, whether the corresponding `ObjectState` is a `VirtualState` (if yes, the **virtual object** needs to be `materialized` before serving as input to a `Phi` node)
- the `MergeProcessor` also examines every already **existing** `Phi` nodes that is **attached** to the `Merge` node looking for **inputs** of the `Phi` node that are **aliased** with `Id`s:
  - **(c)** if they are all **aliased** to the **same** `Id` by their `aliases` **maps**, the `Phi` node is **added** as an `alias` of the `Id`
  - any input that is **aliased** with a **virtual** object needs to be **materialized** (the input in the `Phi` node is replaced with the **materialized value**)
  - if an input is **aliased** with an **escaped** object, the input in the `Phi` node is replaced with the `materializedValue`

---

- the whole process is **iterated until** no additional **materializations** happen **during merging** (**stable** state)
  - some **virtual objects** might be turned into **escaped objects** (some **virtual object** from the previous iteration could change its state, so we need to continue iterating to perform the merge operation correctly)

---

## Loops

- loops are processed iteratively
- at the 1st iteration, the loop body is processed with a **speculative state** which is taken from the loop's predecessor
- iteration stops at the loop's back edges and at loop exits
- after processing the loop, the `MergeProcessor` **merges** the states of the **loop's predecessor** and the **loop back edges**
- the produced state is only **valid** if the **speculative start state** is **correct**:
  - the **new state** is **compared** with the **speculative state**
    - if **not equal**, the loop is **re-processed**
    - else the processing **continues at the loop's exists**

![figure7](figures/figure-7.png)

- loop with 1 exit and 2 back edges
- when iteration encounters the loop only the state `A` is known
- in order to start processing the loop, it is **assumed** that `B` **equals** `A`
- during the iteration, states `C`, `D` and `E` are created
- the `MergeProcessor` merges `A`, `D` and `E` to create a new state `B'`
- if `B'` equals `B`, then `C` is correct and the iteration can continue at `LoopExit`, else `B` is replaced with `B'` and the loop is re-processed

---

## Handling Frame States

- The **Hotspot interpreter cannot work with virtual objects**
  - all **virtual objects** need to be materialized whenever a **deoptimization** occurs
  - the information required to crate the objects needs to be added to the `FrameState` nodes that describe the **mapping** from the **machine state** to the **Java VM state** whenever a **virtual object** is **referenced by the frame state**

```java
static Object global;
void foo(int i) {
    Integer i = new Integer(x);
    global = null;
    ...
}
```

![figure8](figures/figure-8.png)

- 2 **Graal IR fragments with frame state** corresponding to _Listing 8_
  - the `FrameState` nodes are expressed as **dashed boxes** marked with `@` and they contain:
    - the **method name**
    - the **bytecode position**
  - their inputs describe the **local variables** and the **contents of the expression stacks** (in the example are empty)
- **(a)** contains a field store which is associated with _position 9_ in the constructor of `Integer`
  - there are **2 local variables** (the newly allocated `Integer` and the value `x`)
  - the constructor is **inlined** into the method `foo` so it has a reference to the **outer frame** at _position 5_ in `foo`
  - this **outer frame** has only **1 local variable** (the value `x`)
- **(b)** shows the same **Graal IR after** applying **PEA**
  - the first field store is **removed** due to **Scalar replacement**, which also **removes** the **associated `FrameState` nodes**
  - the second field store is **not removed**
    - its **associated frame state** contains a **reference to the virtual object** whose allocation is **removed**
    - this reference to the `New Integer` node is **replaced** with a **reference to the virtual object's `Id`**
    - to be able to **restore** the object during **deoptimization** a copy of the current `VirtualState` for the `Id` is **added to the frame state**

---

## Evaluation

- **PEA** implementation on top of the **Oracle's Graal compiler**
- _server-class Xeon E5-2690 CPUs_
- _Java VM with 2GB of heap_
- **14 benchmarks** of the **DaCapo** suite (with **warmup** to reach a stable peak performance)
- **12 benchmarks** of the **ScalaDaCapo** suite (with **warmup** to reach a stable peak performance)
- **SpecJBB2005** benchmark (contains a **warmup** phase)
- the **entire process** was executed 10 times **without** **PEA** and 10 times **with** **PEA**
- the numbers are the **averages** of the benchmarks **results** for the **10 runs** (respectively)
- in **separate runs** and **for each benchmark**: collection of **statistics** for:
  - the **size and number of allocations**
  - the **number of lock operations**

---

## Results

- the **number of lock operations** are **omitted** because **few** of this numbers are **significant**
- the **not significant** **DaCapo** benchmarks are **omitted**
- for each benchmark the table contains
  - allocation per iteration in MB
  - millions of allocations per iteration
  - iterations per minute metrics
  - split with and without **PEA** and change

![table1](/blog/pea/tables/table-1.png)

- **Allocated bytes**:
  - most benchmarks show **high allocation rate**
- **Number of allocations**:
  - in general, benchmarks with a **high number of allocated bytes** also show a **high number of allocations**
  - the relative **decrease** in the **number of allocations** is usually higher that the **decrease** in the **number of allocated bytes** (**PEA does not remove allocations containing large arrays**)
- **Number of locks**:
  - **no significant reduction** in the **number of lock operations** is observed in most benchmarks
- **Iterations per minute**:
  - most benchmarks show some **improvement** in **performance** (many above 10%)
  - **PEA** can **in rare cases increase the size of compiled methods** which has a **negative influence** on this benchmark

---

## Comparison

- the **Hotspot server compiler** (the most used **JIT compiler performing EA**) benefits less from enabling **EA** than **Graal** does from enabling **PEA**
  - **DaCapo**: 0.9% _vs_ 2.2%
  - **ScalaDaCapo**: 7.4% _vs_ 10.4%
  - **SpecJBB2005**: 5.4% _vs_ 8.7%

---

## Future work

- general parallelization, in particular when ecountering a control split and consequently updating the allocation state
- **PEA** algorithm actually relies on the scheduler to order the nodes in the correct way
  - by adding simple invariants to the **Graal IR** (such as limiting the max distance from nodex fixed in control flow to nodes affected by **PEA**) the analysis could be performed without a scheduler

---

## Conclusions

- new approach to performing **Escape analysis**, **Scalar replacement** and **Lock elision** in a more **fine-grained way**
- this analysis technique does **not ame a global decision** about the **object's escapability** but **propagates** the **state of all allocations** white **iterating over control flow**
- it can thus perform **optimizations on individual branches**
- **combination** of a **control-flow-sensitive analysis** and a **control-flow-insensitive optimization**
- efficient way to implement **EA**
- in the **DaCapo**, **ScalaDaCapo** and **SpecJBB2005** benchmarks **PEA**:
  - can reduce memory allocated by up to 58.5%
  - shows an improvement in performance of up to 33%
